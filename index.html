<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <canvas id="canvas" width="800vh" height="400vh">
    </canvas>
    <input type="button" value="GIOCA" id="playbut">
    <script>
        const canvas = document.getElementById("canvas");
        const shipImage = new Image();
        const bulletImage = new Image();
        const enemyImage = new Image();
        const playbut = document.getElementById("playbut");
        shipImage.src = "img/ship.png";
        bulletImage.src = "img/bullet.png";
        enemyImage.src = "img/enemy.png";
        gameOverText = "SEI GAY"
        gameOverColor = "red"
        context = canvas.getContext("2d");
        let gameOver = false;
        let jumpscareTimer = 0;
        ship_speed = 5;
        bullet_speed = 7;
        enemy_speed = 10;
        bullets = [];
        enemies = [];
        enemies_bullets = [];

        document.body.addEventListener("keydown", keydown)
        document.body.addEventListener("keyup", keyup)

        function keydown(e) {
            console.log("Pressed key: ", e.key)
            switch(event.key){
                case "ArrowLeft":
                    ship.vx = -ship_speed
                    break

                case "ArrowRight":
                    ship.vx = +ship_speed
                    break

                case "ArrowUp":
                    ship.vy = -ship_speed
                    break

                case "ArrowDown":
                    ship.vy = +ship_speed
                    break
                    
                case "f" || "space":
                    ship.shot()
                    break
            }
        }

        function keyup(e) {
            ship.vx = 0;
            ship.vy = 0;
        }

        function drawJumpscare(ctx) {
            ctx.fillStyle = gameOverColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const shakeX = (Math.random() - 0.5) * 20;
            const shakeY = (Math.random() - 0.5) * 20;

            ctx.save();
            ctx.translate(shakeX, shakeY);
            ctx.fillStyle = "black";
            ctx.font = "bold 40px Arial";
            ctx.textAlign = "center";
            ctx.fillText(gameOverText, canvas.width / 2, canvas.height / 2);

            ctx.restore();
            setTimeout(
                ()=>{window.location.reload()}, 80
            )
        }


        function boxDistance(a, b) {
            const dx = Math.max(
                b.x - (a.x + a.w),
                a.x - (b.x + b.w),
                0
            );

            const dy = Math.max(
                b.y - (a.y + a.h),
                a.y - (b.y + b.h),
                0
            );
            return Math.sqrt(dx * dx + dy * dy);
        }

        function visible(entity) {
            return (
                entity.x + entity.w > 0 &&
                entity.x < canvas.width &&
                entity.y + entity.h > 0 &&
                entity.y < canvas.height
            );
        }

        const ship = {
            w: 40, h: 40,
            ctx: context,
            x:canvas.width/2, y: canvas.height-40, vx:0, vy: 0,
            draw: function(){
                this.ctx.drawImage(shipImage, this.x, this.y, this.w, this.h)
            },
            move: function(ctx){
                this.x+=this.vx;
                this.y+=this.vy;

                bullets.forEach(bullet => {
                    bullet.draw(ctx);
                    bullet.move();
                });
            },
            shot: function(){
                bullet = new Bullet(this.x, this.y, 0, -bullet_speed, 20, 20)
                bullets.push(bullet)
            }
        }

        class Entity {
            x;
            y;
            vx;
            vy;
            w;
            h;
            constructor (x, y, vx, vy, w, h){
                this.x=x; this.y=y;
                this.vx=vx; this.vy=vy;
                this.w = w; this.h = 50;
            }
            draw(ctx) {}
            move() {
                this.x += this.vx
                this.y += this.vy
            }
        }

        class Bullet extends Entity { //si ho deciso di imparare le sottoclassi
            draw(ctx) {
                ctx.drawImage(bulletImage, this.x, this.y, this.w, this.h)
                if (!visible(this)){
                    const index = bullets.indexOf(this);
                    if (index !== -1) {
                        bullets.splice(index, 1);
                    }
                }
            }
        }

        class Enemy extends Entity{ //visto? utile no?????????
            move(canvas) {
                this.x += this.vx
                if (this.vx > 0 && this.x > canvas.width-this.w){
                    this.vx = -this.vx
                } else if (this.vx < 0 && this.x <= 0) {
                    this.vx = -this.vx
                }
            }
            draw(ctx) {
                ctx.drawImage(enemyImage, this.x, this.y, this.w, this.h);
                enemies_bullets.forEach(bullet => {
                    bullet.draw(ctx);
                    bullet.move();
                });
            }
            shoot(){
                enemies_bullets.push(
                    new Bullet(this.x, this.y, 0, bullet_speed, 20, 20)
                );
            }
        }

        enemies.push(
            new Enemy(0, 0, enemy_speed, 0, 70, 70),
        )

        function draw(){
            context.clearRect(0,0,canvas.width, canvas.height)
            if (gameOver) {
                drawJumpscare(context);
                jumpscareTimer--;

                if (jumpscareTimer <= 0) {
                    gameOver = false; // remove if you want permanent freeze
                }

                requestAnimationFrame(draw);
                return;
            }
            ship.draw(context)
            ship.move(context)
            bullets.forEach((bullet, bi) => {
                enemies.forEach((enemy, ei) => {
                    d = boxDistance(bullet, enemy)
                    if (d === 0) {
                        gameOver = true;
                        jumpscareTimer = 60;
                        gameOverText = "HAI VINTO E NON FAI SCHIFO"
                        gameOverColor = "green"
                        enemies.splice(ei, 1);
                        bullets.splice(bi, 1);
                    }
                });
            });

            enemies_bullets.forEach((bullet, bi) => {
                d = boxDistance(bullet, ship)
                if (d === 0) {
                    gameOver = true;
                    jumpscareTimer = 60;
                    gameOverText = "HAI PERSO E FAI SCHIFO"
                    gameOverColor = "red"
                    bullets.splice(bi, 1);
                }
            });

            enemies.forEach(enemy =>{
                enemy.draw(context)
                enemy.move(canvas)
                if (Math.abs((enemy.x + enemy.w / 2) - (ship.x + ship.w / 2)) < 10) {
                    setTimeout(() => enemy.shoot(), 10)
                }
            })
            window.requestAnimationFrame(draw);
        }
        playbut.addEventListener("click", () =>{
            window.requestAnimationFrame(draw);
        }
        )
    </script>
</body>
</html>